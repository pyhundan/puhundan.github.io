<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字节跳动面试总结（一）]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2020年字节跳动暑期实习面试在大三下这个学期，我的专业基本上没什么课，而且暑期实习也渐渐的开始招人了，所以几个大厂都投了简历过去，均去了笔试，然而笔试过了的也就只有字节跳动，哎。说到底还是自己菜。在字节跳动的面试中，一面是过了，然后二面十分钟就挂了。就在这里总结一下面试的问题和经验吧。 问题：涉及面还是在专业知识上，算法，语言的基础知识，计算机网络，操作系统都有涉及到。 算法：二面没有坚持到考算法的地步，于是就只有一面考的算法。其中算法考了==全排列==问题。说起来也是巧合，在前一晚隔壁宿舍过来问了这个全排列问题。就在这里列一下代码吧。 12345678910111213141516171819202122232425void perm1(vector&lt;int&gt; &amp;nums,int n,int m)//m是数组大小&#123; if(n==m)//只剩下一个元素的时候输出 //a.push_back(nums); &#123; for(int k=0;k&lt;=m;k++) cout&lt;&lt;nums[k]; cout&lt;&lt;" "; &#125; else &#123; for(int j=n;j&lt;=m;j++) &#123; int temp=nums[j]; nums[j]=nums[n]; nums[n]=temp; perm1(nums,n+1,m); temp=nums[j]; nums[j]=nums[n]; nums[n]=temp; &#125; &#125;&#125; 编程语言OOP（面对对象编程）的概念首先有3个特性，封装性，继承性，多态性。 封装性：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类或者操作进行信息隐藏。也就是只保留接口和方法与外部联系。 继承性：使用现有的类的所有功能，可以无需重新编写原来的类的情况下对这些功能进行扩展。增加代码的重用性。 通过继承的类称为：“子类”或者“派生类” 被继承的类称为：“父类”或者“超类” 继承的过程一般是从一般到特殊的过程。 多态性：多个子类中虽然都有同一个方法，但是这些子类实例化的对象调用这些相同的方法后可以获得不同的结果，多态性增强了软件的灵活性。 实现多态类的方法有三种手段：1、虚方法 2、抽象类 3、接口 重写和重载的区别重写：存在与子类和父类之间，子类定义的方法和父类的方法具有相同的方法名，相同的参数列表和相同的返回类型。 1、子类不同重写final 2、必须重写abstract 重载：同一个类中的多个方法有相同的方法名，但它们具有不同的参数列表，返回类型也可以不一样。 区别：都是实现多态性的方式。重载是实现编译时多态性（静态）。重写时实现运行时的多态性（动态）。重载发生在一个类中，重写发生在子父类之间，必须有相同的返回类型，参数列表，抛出相同的异常等。 C++中的析构函数对象消亡的时候自动调用，释放对象占用的内存。 特点： 1、函数名时在类名前加上～，无参数且无返回值。 2、一个类只能有且只有一个析构函数，如果没有显式的定义，系统会生成一个缺省的析构函数。 3、析构函数不能重载。每有一次构造函数的调用就会有一次析构函数的调用。 java 两个被相互引用的对象能否被回收举个例子： 123456789101112131415161718class A&#123; public B bb;&#125;class B&#123; public A aa;&#125;public class Test&#123; public static void main(String[] args)&#123; A a=new A(); B b=new B(); a.bb=b; b.aa=a; a=null; b=null; &#125;&#125; 具体没找到具体的答案，但是找到了一些java回收机制。两个互相引用对象的垃圾回收 判断对象是否存活。 1、引用计数法: 给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1。任何时候计数器为0的对象就是不可能再被使用的。但是主流的java虚拟机没有采用引用计数法，其中最主要的原因就是他很难解决上面的问题，也就是对象之间相互引用的问题。 2、可达性分析算法（主流）： 基本思想：通过一系列的被称为“gc roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“gc roots”没有任何引用链相链接时候，则此证明对象时不可用的。 可作为“gc roots”的对象 （1）虚拟机栈（栈针中的局部变量表）中引用的对象。 （2）方法区中类静态属性引用的对象。 （3）方法区中常量引用的对象。 （4）本地方法栈中JNI引用的对象。 等有空了再更新之后的内容，也就是操作系统和计算机网络的，无非也是考那几样内容，主要还是自己学过的忘记了。 参考： C++之类的析构函数]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo提交sitemap提示URL错误]]></title>
    <url>%2F2019%2F04%2F15%2Fabouttogoogle%2F</url>
    <content type="text"><![CDATA[问题新博客搭建后，安装网上教程一步步来，后来发现他们的教程都是老版的教程，baidu和google的站点服务均换了新版，baidu现在需要实名制了，要手持身份证，我思考了一番觉得十分的麻烦，所以只提交google上，但是提交后发现下面的问题： 点开发现说是URL出错，后来网上找了篇文章才解决问题。 具体是修改 node_modules/hexo-generator-sitemap/sitemap.xml中的代码： 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"&gt; &#123;% for post in posts %&#125; &lt;url&gt; &lt;loc&gt;&#123;&#123; (config.urlforgoogle+post.path) | uriencode &#125;&#125;&lt;/loc&gt; &#123;% if post.updated %&#125; &lt;lastmod&gt;&#123;&#123; post.updated.toISOString() &#125;&#125;&lt;/lastmod&gt; &#123;% elif post.date %&#125; &lt;lastmod&gt;&#123;&#123; post.date.toISOString() &#125;&#125;&lt;/lastmod&gt; &#123;% endif %&#125; &lt;/url&gt; &#123;% endfor %&#125;&lt;/urlset&gt; 其中urlforgoogle是个变量，在根目录中的 _config.yml中添加： 1urlforgoogle: http://www.frozenluo.club/ 然后hexo d -g,再在google search console提交sitemap便可以通过。 参考链接：]]></content>
      <categories>
        <category>next</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于gemini和Pisces的BUG]]></title>
    <url>%2F2019%2F04%2F14%2FBUG%2F</url>
    <content type="text"><![CDATA[展示问题​ 在我搭建的过程中，我发现我的博客出现了以下的效果。 ​ ​ (图均来自https://github.com/theme-next/hexo-theme-next/issues/426) 而我期望的效果为： 解决方案：在上面所诉的连接中，找到了解决这个bug的办法。打开source/js/src/schemes/pisces.js文件，将代码从19行开始修改，注释其中的代码，增加相应的函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*function setSidebarMarginTop(headerOffset) &#123; return $('#sidebar').css(&#123; 'margin-top': headerOffset &#125;); &#125;*/ function initAffix() &#123; var headerOffset = getHeaderOffset(); var footerOffset = getFooterOffset(); /* var sidebarHeight = $('#sidebar').height() + NexT.utils.getSidebarb2tHeight(); var contentHeight = $('#content').height(); // Not affix if sidebar taller then content (to prevent bottom jumping). if (headerOffset + sidebarHeight &lt; contentHeight) &#123; sidebarInner.affix(&#123; offset: &#123; top : headerOffset - sidebarOffset, bottom: footerOffset &#125; &#125;); &#125; setSidebarMarginTop(headerOffset).css(&#123; 'margin-left': 'initial' &#125;); &#125;*/ /* function recalculateAffixPosition() &#123; $(window).off('.affix'); sidebarInner.removeData('bs.affix').removeClass('affix affix-top affix-bottom'); initAffix(); &#125; */ sidebarInner.affix(&#123; offset: &#123; top : headerOffset - sidebarOffset, bottom: footerOffset &#125; &#125;); $('#sidebar').css(&#123; 'margin-left': 'initial', 'margin-top': headerOffset &#125;); sidebarInner.affix('checkPosition'); &#125; function resizeListener() &#123; var mql = window.matchMedia('(min-width: 991px)'); mql.addListener(function(e) &#123; if (e.matches) &#123; //recalculateAffixPosition(); sidebarInner.affix('checkPosition'); initAffix(); &#125; &#125;); &#125; initAffix(); resizeListener(); // Fixed wrong top alignment if page scrolled to the bottom after cleared cache and browser refresh./* sidebarInner.affix('checkPosition');*/&#125;); 之后便可以解决上诉问题。]]></content>
      <categories>
        <category>next</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[second]]></title>
    <url>%2F2019%2F04%2F12%2Fsecond%2F</url>
    <content type="text"><![CDATA[重新捡回​ 重新捡回这个blog，来记录自己的点点滴滴。在捡回的过程中也是出现了些问题。 域名过期了​ 这个实在是头疼，网络上很多的教程都是记录如何绑定域名的，而不是如何解除绑定的，后来找到一篇文章： 12345678 清空CNAME文件，再提交一次。如果直接删除项目，无法触发后台的域名更新操作。所以，应该这样处理，提交成功等一会再访问xxx.github.io，就不会跳到自定义的域名了。如果发现还不行，就有可能是浏览器缓存的问题，导致重定向了，清空下缓存就可以了。步骤如下：1、hexo clean2、将CHAME内容去掉，留个空白文档3、hexo g4、hexo d ​ 后来发现还是一直跳转到以前的域名，直到问了舍友，找回了以前的域名，把以前域名解析了才搞定。浪费了几十块钱。 生成的CNAME文件有域名​ 找来找去没找到解决办法，也就只能每次 1hexo g ​ 之后删掉CNAME中的域名在执行。 1hexo d 好了好了，最后找回来了，还算是没有浪费时间。]]></content>
      <categories>
        <category>next</category>
      </categories>
      <tags>
        <tag>解除域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2018%2F09%2F30%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[记录第一次​ 摸索了一个早上，终于把这个基于github的博客给搭建好了，在搭建的过程中还是比较顺利的。 ​]]></content>
      <categories>
        <category>next</category>
      </categories>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
</search>
